# TAO.BEM
TAO.BEM - инструмент, предназначен для удобной работы при использовании [методологии БЭМ](https://tech.yandex.ru/bem/). Он представляет абстракции над основными понятиями БЭМ - Блоком, Элментом, Модификатором, позволяет 
  легко обрабатывать события и многое другое.
  
Суть использования сводится к описанию требуемых блоков в виде js классов и инкапсуляции необходого состояни в 
объектах этих классов 

## Установка
Для установки пакета, можно воспользоваться npm

``` bash
npm install @webtechart/tao-bem
```

## Подключение и использование

Для описания минимально рабочего блока нужно создать отдельный класс, описывающий этот блок, наследующий класс
 базового блока TAO.BEM. В новом классе *обязательно* переопределить статический геттер `blockName()`, который должен возвращать css-класс данного блока.
 
Помимо описания блока, нам нужно рассказать TAO.BEM, что наш блок существует, вызвав на нём статический метод
 `register()`.

В приведённом ниже примере предполагается испольщование сборщика 

``` js
import BEM from 'tao-bem'

class ExampleBlock extends BEM.Block {
    static get blockName() {
        return 'b-exmaple';
    }
}

ExampleBlock.register()
```
 
Выше мы создали и зарегистрировали самый простой блок. Правда абсолютно бесполезный. Попробуем добавить немного логики
 в наш блок.
 
Переопределив метод `onInit()` мы получим возможность произвести необходимую подготовку в тот момент, когда TAO.BEM 
  обнаруживает в DOM-дереве элемент блока и обрабатывает связанные с ним скрипты. Пока для примера оставим простое
  сообщение в консоли.

Переопределив статический геттер `events()` мы подписываемся на события вызываемые на блоке. В данном случае мы вызываем метод `makeSomeNoise` при клике по блоку и выводе курсора с блока.

Переопределив статический геттер `modsEvents()` мы добавили обработчик на изменение модификатора `test-mod` самого блока и изменении модификатора `disabled` у элемента `button` этого блока (т.е. на переключение класс `b-example__button--disabled` у элемента с классом `b-example__button`).
 
Переопределив статический геттер `elementsEvents()` мы добавили обработчик на клик по элементу `button` (класс `b-example__button`).

```js

import BEM from 'tao-bem'

class ExampleBlock extends BEM.Block {
    static get blockName() {
        return 'b-example';
    }
    
    onInit() {
        console.log('Instance of ExampleBlock initialized!');
    }
    
    static get events() {
        return {
            click: function(event) {
                this.makeSomeNoise();
                event.stopPropagation();
            },
            mouseout: 'makeSomeNoise'
        };
    }
    
    static get modsEvents() {
    	return {
    		onMod: {
                'test-mod': function(modValue, modName) {
                    this.makeSomeNoise(modValue);
                }
            },
            onElemMod: {
                'button' : {
                    'disabled': function (modValue, modName) {
                        this.makeSomeNoise();
                    }
                }
            }
        };
    }
    
    static get elementsEvents() {
    	return {
    		'button.click': function(element, allElements, event) {
    			window.location.reload();
    		}
    	};
    }
    
    makeSomeNoise(noiseLevel = 0) {
        alert('Noise!' + (noiseLevel ? ' Going to noise level ' + noiseLevel : ''));
    }
}

ExampleBlock.register();

```

### Инициализация блоков

При подключении TAO.BEM скрипт обходит имеющееся DOM-дерево (важно отметить, что он не дожидается загрузки всего документа, поэтому лучше подключать его перед закрывающим тегом `body`), отыскивает DOM-элементы с классами зарегестрированных блоков (тех, что блоки возвращают из статического геттера `blockName`) и для каждого одних создаются экземпляры соотвествующих классов BEM-блоков.
 
Также скрипт подписывается на изменения DOM-дерева, и при последующих добавлениях новых DOM-элементов для них также при необходимости будут созданы экземпляры BEM-блоков.

При необходимости стартовая автоматическая инициализация блоков может быть заменена "ленивой" инициализацией, при первом появлении блока на экране. Для этого нужно переопределить статический геттер `forced()` у класса блока и вернуть из него `false`.  

### Организация структуры блоков

После инициализации ссылки на все созданные блоки попадают в Регистр. Если у вас есть ссылка на DOM-элемент являющийся блоком, то из Регистра вы можете получить соответствующий ему BEM-объект с помощью метода `getInstance($node, name)`.
 
```js
import BEM from 'tao-bem';

let $node = $('.b-example');
let exampleBlock = BEM.Registry.getInstance($node, 'b-example');
exampleBlock.makeSomeNoise();
```

Для удобства манипулирования наборами блоков введено поятие Коллеций. Коллеция - это специальный объект, который позволяет хранить несколько блоков и выплонять над ними групповые операции.

Объект коллекции наследует коллекцию из TAO.Core, поэтому в нём доступны все методы родителя. Помимо этого существуют несколько специфичных методов, которые позволяют изменять модификаторы всем элементам коллекции (`addMod(name, state)`, `delMod(name, state)`, `toggleMod(name, state)`) и метод `byMod(name, state)` для фильтрации элементов коллекции по значению модификатора.

Для получения коллекции блоков необходимо воспользоваться Регистром - методом `getCollection(name)`. Помимо этого можно воспользоваться статическим методом `getCollection()` класса требуемого блока.

```js

import BEM from 'tao-bem';

// ниже два примера идентичного кода
let collection = BEM.Registry.getCollection('b-example');
collection.first().makeSomeNoise();

let sameCollection = ExampleBlock.getCollection();
sameCollection.first().makeSomeNoise();
```
 
У каждого блока с помощью метода `elems(name)` можно получить коллекцию его элементов, и первый из элементов с помощью метода `elem(name)`. 

```js
import BEM from 'tao-bem';

let $node = $('.b-example');
let exampleBlock = BEM.Registry.getInstance($node, 'b-example');
let buttons = exampleBlock.elems();
let firstButton = exampleBlock.elem();

buttons.delMod('disabled');
firstButton.addMod('disabled');
```

Для блоков возможно переопределить класс коллекции, чтобы расширить его дополнительными методами. Для этого нужно переопределить статический метод `makeCollection()` класса блока. Из него нужно вернуть новый объект коллекции, который будет использоваться для хранения блоков.

### Обработка событий блока

Во время жизни блока скорее всего ему придётся как-то взаимодействовать с окружающим его кодом и реагировать на действия пользователей. Такие взаимодействия удобно организовывать в виде событий. Для обработки событий блока в TAO.BEM существует несколько статических геттеров:

#### `events()` 

Используется для подписки на события самого блока. Этот метод должен вернуть хэш-таблицу (обычный объект JS), ключами которой являются имена событий, на которые мы хотим подписатсья, а значениями - обработчики. В качестве обработчика может выступать как привычная всем анонимная функция (можно использовать и стрелочные функции, но в них будет потерян контекст `this`, а значит вам придётся явно получать объект блока, на котором произошло событие), так и строка, содержащая имя метода класса блока.

#### `modsEvents()`

Используется для подписки на события изменения значений модификаторов блока. Удаление модификатора обрабатывается как событие изменения значения модификатора на `false`, а добавление модификатора без значения обрабатыавется как событие изменения значения модификатора на `true`.

В обработчик будет передано новое значение модификатор и имя модификатора. Текущим контекстом будет класс блока.

Важно понимать, что обработка событий будет происходить только при изменении модификаторов через api TAO.BEM, т.е. вызовами методов `addMod`, `delMod`, `toggleMod` и `mod`. Также обработчик однократно сработает при инициализации блока для всех модификаторов, которые присутствуют на DOM-элементе.

Вернув из обработчика `false`, можно отменить изменение модификатора (однако обработчик вызванный на событии при инициализации блока не сможет таким образом "сбросить" модификаторы).

Помимо общих обработчиков на изменение модификаторов возможно подписываться на присвоение определённым модификаторам определённых значений. В этом случае обработчик будет срабатывать только если модификатор получает подходящее значение. Ниже приведён пример

```js

import BEM from 'tao-bem'

class ExampleBlock extends BEM.Block {
    static get blockName() {
        return 'b-example';
    }
    
    static get modsEvents() {
        return {
            onMod: {
                'some-mod': {
                	'some': function(modValue, modName) {
                        this.makeSomeNoise(modValue);
                    },
                    'someOther': function(modValue, modName) {
                        this.makeSomeNoise(modValue);
                    }
                }
            }
        };
    }
    
    makeSomeNoise(noiseLevel = 0) {
        alert('Noise!' + (noiseLevel ? ' Going to noise level ' + noiseLevel : ''));
    }
}

ExampleBlock.register()

```

Также можно навешивать обработчики на измнение модификаторов элементов блока. Работает это аналогично добавлению обаботчиков на изменение модиикаторов блока, только ключом будет не `onMod`, а `onElemMod`. Ниже пример

```js

import BEM from 'tao-bem'

class ExampleBlock extends BEM.Block {
    static get blockName() {
        return 'b-example';
    }
    
    static get modsEvents() {
        return {
            onElemMod: {
            	'button': {
                    'disabled': function(modValue, modName) {
                        this.makeSomeNoise(modValue);
                    },
                }
            }
        };
    }
    
    makeSomeNoise(noiseLevel = 0) {
        alert('Noise!' + (noiseLevel ? ' Going to noise level ' + noiseLevel : ''));
    }
}

ExampleBlock.register()

```

#### Автомодификаторы

Для блока можно включить автоматическое переключение определённых модификаторов при наступлении определённых событий блока. На текущий момент поддерживаются следующие события:

* `hover` - наведение курсора мыши
* `press` - клик
* `focus` - полчение фокуса

Для включения автомодификаторов нужно переопределить статический геттер `mods()` и вернуть из него строку, содержащую список необходимых модификаторов, разделённых пробелом.

```js

import BEM from 'tao-bem'

class ExampleBlock extends BEM.Block {
    static get blockName() {
        return 'b-example';
    }
    
    static get mods() {
        return 'hover press';
    }
}

ExampleBlock.register();

```

#### Взаимодействие между блоками

Coming soon.
